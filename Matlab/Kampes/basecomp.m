function [thi, R, Bperp]=basecomp(row, col, master, slave)
% 此函数用于从GAMMA生成的基线以及ISP参数文件中提取基线参数――差分干涉/投影转换
%%function  [thi, R, Bperp]=basecomp(row, col, master, slave);
%
% This function is used to extract the baseline parameters based on the baseline- 
% and ISP-parameter files generated by Gamma -- Differential Interferometry/Geocoding. 
% 
% Input:
%        row-------------azimuth-pixel coordinates in SAR coordinate system, a vector of N by 1
%        col--------------range-pixel coordinates in SAR coordinate system, a vector of N by 1
%        master---------acquisition date of master image, its format is "yymmdd" 
%        slave-----------acquisition date of slave image, its format is "yymmdd" 
%                     Note: both baseline- and ISP-parameter files generated by
%                              Gamma are required for the successful calculation
%                              of baseline parameters. For the case of Phoenix, 
%                              see "F:\Phoniex\base_par_files" and "F:\Phoniex\ISP_par_files"!!
%
% Output:
%        thi--------------radar look angles (in radian) with respect to the reference surface -- 
%                             e.g., WGS84 ellipsoidal surface, a vector of N by 1
%        R---------------slant ranges (sensor-surface distance) in meters, a vector of N by 1
%        Bperp---------perpendicular-baseline values in meters, a vector of N by 1
%
% %  e.g.,    [thi, R, Bperp] = basecomp(500, 3000, 19920710, 19930521);
%
% Original Author:  Guoxiang LIU
% Revision History:
%                   Apr. 10, 2006: Created, Guoxiang LIU
%
% See also PS_DETECT, PS_TIN, PHEXTR, BASECOMP

%t0=cputime;
% open the baseline-parameter (TCN) file generated by Gamma
Dirt='F:\Phoniex\base_par_files\';                                             % given the directory of baseline-parameter files
%Dirt='/d1/users/liu/PhoenixDIF/base_files/';                            % for Unix system
infile=[Dirt, num2str(master), '_', num2str(slave), '.base'];      % get a file name corresponding to baseline parameters
fid1 = fopen(infile, 'rt');
if (fid1<0) error(ferror(fid1)); end;

% open the masetr ISP-parameter file generated by Gamma
Dirt='F:\Phoniex\ISP_MLI_par_files\';
%Dirt='/d1/users/liu/PhoenixDIF/ISP_MLI_par_files/';                            % for Unix system
infile=[Dirt, num2str(master), '.pwr12.par'];
fid2 = fopen(infile, 'rt');
if (fid2<0) error(ferror(fid2)); end;
clear infile Dirt;

% read TCN parameters from fid1 (--baseline-parameter file)
temp=fscanf(fid1, '%s', 1);
Const_TCN=fscanf(fid1, '%f', 3);     % get constant terms of three baseline components (intial baseline from orbit data)
temp=fscanf(fid1, '%s', 3);
temp=fscanf(fid1, '%s', 1);
Linear_TCN=fscanf(fid1, '%f', 3);    % get linear terms of three baseline components (intial baseline rate from orbit data)

% read some key parameters from fid2 (--master SAR ISP-parameter file)
for i=1:4
     tline = fgetl(fid2);    % skip the first four lines in fid2
end
temp=fscanf(fid2, '%s ', 1);      % to "date:"
year=fscanf(fid2, '%s ', 1);      % get year
month=fscanf(fid2, '%s ', 1);   % get month
date=fscanf(fid2, '%s ', 1);      % get date
if (length(month)==1)
    month=['0', month];
end
if (length(date)==1)
    date=['0', date];
end
ymd=[year, month, date];    % generate a date with format of "yyyymmdd"
if (ymd~=num2str(master))
    disp('\nError message: confused date of acquiring SAR image!');
    return;
end

temp=fscanf(fid2, '%s ', 1);   
start_time=fscanf(fid2, '%f ', 1);         % get start time of SAR acquisition
temp=fscanf(fid2, '%s ', 1);  
temp=fscanf(fid2, '%s ', 1);   
center_time=fscanf(fid2, '%f ', 1);      % get central time of SAR acquisition
temp=fscanf(fid2, '%s ', 1);   
tline = fgetl(fid2);                                 % skip one line in fid2
temp=fscanf(fid2, '%s ', 1);   
azimuth_line_time=fscanf(fid2, '%f ', 1);  % get time spacing along azimuth direction
temp=fscanf(fid2, '%s ', 1);                

tline = fgetl(fid2);    % skip one line in fid2

temp=fscanf(fid2, '%s ', 1);   
range_samples=fscanf(fid2, '%d ', 1);           % get range samples
temp=fscanf(fid2, '%s ', 1);   
azimuth_lines=fscanf(fid2, '%d ', 1);              % get azimuth lines

for i=1:9
     tline = fgetl(fid2);    % skip 11 lines in fid2
end

temp=fscanf(fid2, '%s ', 1);   
range_pixel_spacing=fscanf(fid2, '%f ', 1);      % get range pixel spacing
temp=fscanf(fid2, '%s ', 1);   
tline = fgetl(fid2);    % skip the 23-th line in fid2
temp=fscanf(fid2, '%s ', 1);   
near_range=fscanf(fid2, '%f ', 1);      % get range pixel spacing
temp=fscanf(fid2, '%s ', 1);   

for i=1:18
     tline = fgetl(fid2);    % skip 11 lines in fid2
end

temp=fscanf(fid2, '%s ', 1);   
H=fscanf(fid2, '%f ', 1);      % get nominal distance from sar to the earth's center
temp=fscanf(fid2, '%s ', 1);   
temp=fscanf(fid2, '%s ', 1);   
r=fscanf(fid2, '%f ', 1);       % get the earth's radius
temp=fscanf(fid2, '%s ', 1);   

tline = fgetl(fid2);    % skip one line in fid2
tline = fgetl(fid2);    % skip one line in fid2

temp=fscanf(fid2, '%s ', 1);   
num_OrbPos=fscanf(fid2, '%d ', 1);      % get total number of orbital positions with known state vectors
temp=fscanf(fid2, '%s ', 1);   
time_of_first_state_vector=fscanf(fid2, '%f ', 1);     % get time (in seconds) of the first state vector
temp=fscanf(fid2, '%s ', 1);  
temp=fscanf(fid2, '%s ', 1);   
state_vector_interval=fscanf(fid2, '%f ', 1);     % get time interval (in seconds) between two neighbouring state vectors
temp=fscanf(fid2, '%s ', 1); 
x=zeros(1, num_OrbPos);
y=zeros(1, num_OrbPos);
z=zeros(1, num_OrbPos);
t=zeros(1, num_OrbPos);
vx=zeros(1, num_OrbPos);
vy=zeros(1, num_OrbPos);
vz=zeros(1, num_OrbPos);

% read orbit positions and establish orbital models
for i=1:num_OrbPos
    temp=fscanf(fid2, '%s ', 1);  
    t(i)=time_of_first_state_vector+(i-1)*state_vector_interval-center_time;   % get time at the the i-th orbit position
    x(1,i)=fscanf(fid2, '%f ', 1);      % get x coordinate at the i-th orbit position
    y(1,i)=fscanf(fid2, '%f ', 1);      % get y .....
    z(1,i)=fscanf(fid2, '%f ', 1);      % get z ..... 
    temp=fscanf(fid2, '%s ', 3);
    %temp=fscanf(fid2, '%s ', 1);  
    %vx(1,i)=fscanf(fid2, '%f ', 1);      % get vx velocity at the i-th orbit position
    %vy(1,i)=fscanf(fid2, '%f ', 1);      % get vy .....
    %vz(1,i)=fscanf(fid2, '%f ', 1);      % get vz ..... 
    %temp=fscanf(fid2, '%s ', 3);
    tline = fgetl(fid2);    % skip one line in fid2
end
coef_x=polyfit(t, x, 4);     % Output model: x=coef_x(1)*t^4 +coef_x(2)*t^3 + coef_x(3)*t^2+ coef_x(4)*t + coef_x(5)
coef_y=polyfit(t, y, 4); 
coef_z=polyfit(t, z, 4); 
%coef_vx=polyfit(t, vx, 4);     % Output model: x=coef_vx(1)*t^4 +coef_vx(2)*t^3 + coef_vx(3)*t^2+ coef_vx(4)*t + coef_vx(5)
%coef_vy=polyfit(t, vy, 4); 
%coef_vz=polyfit(t, vz, 4); 

% calculate the time and range of the current pixel with coordinates of (row, col)
current_time=start_time+(row-1)*azimuth_line_time-center_time;    % in seconds
R=near_range+(col-1)*range_pixel_spacing;   % get range

% calculate radar look angle using the ellipsoidal geometry in stead of spherical geometry
%M=[coef_x; coef_y; coef_z; coef_vx; coef_vy; coef_vz];    % form orbital models with 6 freedoms
%[Sat_Pos, XYZ, LLH, thi, dep, inc, b] = SARCoord2ECR_SBAS(M, R, current_time, 0, 0);

% calculate orbit position corresponding to the current pixel
x_s=polyval(coef_x, current_time);
y_s=polyval(coef_y, current_time);
z_s=polyval(coef_z, current_time);
H=sqrt(x_s.^2+y_s.^2+z_s.^2);      % get real distance from sar to the earth's center
clear x_s y_s z_s;

% calculate radar look angle of the current pixell (assuming its height to be zero) 
% using the spherical geometry
thi=acos((H.^2+R.^2-r.^2)./(2*H.*R));    % in radians
clear H;

% calculate the TCN baseline components of the current pixel
TCN=[Const_TCN(1)+Linear_TCN(1)*current_time,  Const_TCN(2)+Linear_TCN(2)*current_time, Const_TCN(3)+Linear_TCN(3)*current_time];
 % get three baseline components
%TCN=Const_TCN+Linear_TCN*current_time
 
% transform TCN into out, perpendicular, and parallel baseline components
%tran_matrix=[1 0 0; 0 cos(-thi) sin(-thi); 0 -sin(-thi) cos(-thi)];      % form transformation matrix
%Ball=tran_matrix*TCN;                                                                  % this method suggested by Douchul Yang, UT, Apr. 10, 2006
Bperp=cos(-thi).*TCN(:,2)+sin(-thi).*TCN(:,3);

%thi=thi*180/pi;         % conversion of unit of radar look angle (radian to degree)
%Bperp=Ball(2);        % get parallel baseline component
%Bparp=Ball(3);        % get perpendicular baseline component

%disp(['% Total CPU time used for the whole processing:  ', num2str(cputime-t0), ' seconds.']);

fclose(fid1);
fclose(fid2);



