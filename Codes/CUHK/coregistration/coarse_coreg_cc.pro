;+
; Purpose:
;     Do coarse coregistration according to cc
; Calling Sequence:
;    result = COARSE_COREG_CC(master, slave, s_offset, l_offset, c_outfile= c_outfile, off_outfile= off_outfile, $
;                          winsearch=winsearch,winsub=winsub,degree=degree, $
;                          mns=MNS, mnl=MNL, sns=SNS, snl=SNL, $
;                          ccp_s=ccp_s,ccp_l=ccp_l,allpoints=allpoints,acc=acc
; Inputs:
;    master       : masterSLC
;    slave        : slaveSLC
;    s_offset     : Coarse offset in x-direction generated by Micheal's.
;    l_offset     : Coarse offset in y-direction generated by Micheal's.
; Optional Input Parameters:
;    None
; Keyword Input Parameters:
;    c_outfile    : File path of coarse result.
;    off_outfile  : File path of offs on the control points. No set, no output.
;    winsearch    : Search window.
;    winsub       : Window used to calculate cc.
;    degree       : Degree of polynomial.
;    mns          : Master samples.
;    mnl          : Master lines.
;    sns          : Slave samples.
;    snl          : Slave lines.
;    ccp_s        : Control points per sample.
;    ccp_l        : Control points per line.
;    allpoints    : All control points. If this were set, then the upper two params are ignored.
;    acc          : Accuracy of coarse coreg cc.
; Outputs:
;    LS coefficients between master and slave.
;    To use the coefficients, please see coormtos.pro
; Commendations:
;    winsearch    : Less than 10. This depends on precision of coarse coreg.
;    winsub       :  More than 512. The larger, the better. But not more than 500.
; Example:
;    master= 'D:\ISEIS\Data\Img\ASAR-20070726.slc'
;    slave= 'D:\ISEIS\Data\Img\ASAR-20060601.slc'
;    s_offset=32
;    l_offset=53
;    MNS=5195
;    MNL=27313
;    SNS=5195
;    SNL=27301
;    outfile= FILE_DIRNAME(master)+PATH_SEP()+FILE_BASENAME(slave, '.slc')+'.rslc'
;    c_outfile= FILE_DIRNAME(master)+PATH_SEP()+FILE_BASENAME(master,'.slc')+'-'+FILE_BASENAME(slave, '.slc')+'.coff'
;    off_outfile = FILE_DIRNAME(master)+PATH_SEP()+FILE_BASENAME(master,'.slc')+'-'+FILE_BASENAME(slave, '.slc')+'.coff.pts'
;    result= COARSE_COREG_CC(master,slave, s_offset, l_offset, c_outfile= c_outfile, off_outfile= off_outfile, $
;                            winsearch=32,winsub=512,mns=MNS, mnl=MNL, $
;                            sns=SNS, snl=SNL,degree=1,ccp_s=7,ccp_l=7)
; Modification History:
;    15/02/2012: Written by T. Li @ InSAR Team in SWJTU & CUHK.
;    09/05/2012: Adjust the structure to read more easily.

FUNCTION COARSE_COREG_CC, master, slave, s_offset, l_offset, c_outfile= c_outfile, off_outfile= off_outfile, $
                          winsearch=winsearch,winsub=winsub,degree=degree, $
                          mns=MNS, mnl=MNL, sns=SNS, snl=SNL, $
                          ccp_s=ccp_s,ccp_l=ccp_l,allpoints=allpoints,acc=acc

  COMPILE_OPT idl2

  IF N_PARAMS() NE 4 THEN $
    result= DIALOG_MESSAGE('Usage:'+STRING(13b)+'    result= COARSE_COREG_CC(master,slave,s_offset,l_offset)')
  IF ~KEYWORD_SET(c_outfile) THEN $
    c_outfile= FILE_DIRNAME(master)+PATH_SEP()+FILE_BASENAME(master,'.slc')+'-'+FILE_BASENAME(slave, '.slc')+'.coff'
  IF ~KEYWORD_SET(winsearch) THEN $
    winsearch= 32
  IF ~KEYWORD_SET(winsub) THEN $
    winsub=512
  IF ~KEYWORD_SET(ccp_s) THEN $
    ccp_s = 10D ; 10 points in range direction.
  IF ~KEYWORD_SET(ccp_l) THEN $
    ccp_l = 10D ; 20 points in azimuth direction.
  IF ~N_elements(Degree) THEN $
    Degree=1
  IF ~(KEYWORD_SET(acc)) THEN $
    acc=8D
  ;- Initialization
  ;----------------------以下为需要读入的参数-----------------------------
  master_ss = MNS ;READ_PARAMS(master_h, 'range_samples')-1
  master_ls = MNL ; READ_PARAMS(master_h, 'azimuth_lines')-1
  slave_ss = SNS ; READ_PARAMS(slave_h, 'range_samples')-1
  slave_ls= SNL ;READ_PARAMS(slave_h, 'azimuth_lines')-1
  ;----------------------以上为需要读入的参数-----------------------------
 	
  temp= MIN([master_ss, master_ls])-winsub/2-5
  IF winsub GT slave_ss OR winsub GT slave_ls THEN result= DIALOG_MESSAGE('Master SLC is to small.')
  IF winsearch GT master_ss OR winsearch GT master_ls THEN reuslt= DIALOG_MESSAGE('Slave SLC is to small.')

  ;------------First calculate the conjunction-----------
  conjunction= FLTARR(4); 起始行，终止行，起始列，终止列。主影像坐标系。
  conjunction[0] = (-s_offset) > 0;起始列
  conjunction[1] = (master_ss-s_offset) < master_ss;终止列
  conjunction[2] = (-l_offset) > 0; 起始行
  conjunction[3] = (master_ls-l_offset) < master_ls; 终止行
  conjunction= conjunction+[ FLOOR((winsearch+winsub)/2)+winsearch+acc,$
                            -FLOOR((winsearch+winsub)/2)-winsearch-acc-((MNS-SNS)>0),$
                            +FLOOR((winsearch+winsub)/2)+winsearch+acc,$
                            -FLOOR((winsearch+winsub)/2)-winsearch-acc-((MNL-SNL)>0)]

  ;------------Decide the control points----------
  cp_coor= TLI_spreadpoints(conjunction,pointsperl= ccp_s, pointspers= ccp_l, allpoints=allpoints);确定控制点
;  x= REAL_PART(cp_coor);横坐标
;  y= IMAGINARY(cp_coor);纵坐标

  ;------------Calculate offsets for each point----------
  offsets= [0,0,0,0,0];[master_s, master_l, slave_s, slave_l, cc]
  FOR i=0, N_Elements(cp_coor)-1 DO BEGIN
    PRINT, STRING(i)+'/'+STRING(N_Elements(cp_coor)-1)
    master_s= REAL_PART(cp_coor[i])
    master_l= Imaginary(cp_coor[i])
    result= Largest_cc(master, slave, master_s, master_l, s_offset, l_offset,$
                       winsub=winsub, winsearch=winsearch, $
                       MNS=MNS, MNL=MNL,SNS=SNS, SNL=SNL, $
                       sample_acc= sample_acc, line_acc=line_acc, ovsfactor=ovsfactor)
    PRINT, master_s, master_l, s_offset, l_offset, result[0]-master_s-s_offset, result[1]-master_l-l_offset,result[2]
    offsets=[[offsets],[master_s, master_l, result]]
    
    
  ENDFOR
 
  offsets=offsets[*,1:*]
  index_sort= SORT(offsets[4,*])
  offsets= offsets[*,index_sort]

  ;------------Polyfit-----------------------------------
  result= TLI_POLYFIT(offsets, degree=degree)
  
  OPENW, lun, c_outfile,/GET_LUN
  result= DOUBLE(result)
  WriteU, lun, DOUBLE(result)
  FREE_LUN, lun

  IF KEYWORD_SET(off_outfile) THEN BEGIN
    OPENW, lun, off_outfile,/GET_LUN
    PRINTF, lun, '; ENVI Image to Image GCP File '
    PRINTF, lun, '; base file: '+master
    PRINTF, lun, '; warp file: '+slave
    PRINTF, lun, '; Base Image (x,y), Warp Image (x,y)'
    PRINTF, lun, ';'
    PRINTF, lun, offsets;offsets[0:3,*]
    FREE_LUN, lun
  ENDIF
  RETURN, result

END