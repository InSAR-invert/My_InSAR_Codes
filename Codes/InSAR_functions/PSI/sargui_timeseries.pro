

PRO Incsolut,num_intf,dinf,r,thi,bperp,dt,dv,ddh,coh
  dv_low=-0.03
  dv_up=0.03
  ddh_low=-15.0
  ddh_up=15.0
  dv_size=21
  ddh_size=21
  dv_inc=(dv_up-dv_low)/(dv_size-1)
  ddh_inc=(ddh_up-ddh_low)/(ddh_size-1)
  dv_try=LINDGEN(21)*dv_inc+dv_low
  ddh_try=LINDGEN(21)*ddh_inc+ddh_low
  Meshgrid,dv_try,ddh_try,dv,ddh
  xdv=REFORM(dv,N_ELEMENTS(dv),1)
  xddh=REFORM(ddh,N_ELEMENTS(ddh),1)
  y=Objfun(xdv,xddh,num_intf,dintf,thi,rang,bperp,dt)
  coh=MAX(y,max_subscript)
  tt(1)=xdv(max_subscript)
  tt(2)=xddh(max_subscript)          ;intial solution obtained from coarse-grid solution space
  ;------------------------------------
  dvinc=2*dv_inc/20
  ddhinc=2*ddh_inc/20
  nv=FLOOR((2*dv_inc)/dvinc+1.0e-5)+1l
  nh=FLOOR((2*ddh_inc)/ddhinc+1.0e-5)+1l
  dv_try=LINDGEN(nv)*dvinc+(tt(1)-dv_inc)           ;all possible veclocity increments at all grid points
  ddh_try=LINDGEN(nh)*ddhinc+(tt(2)-ddh_inc)        ;all possible height-error increments at all grid points
  Meshgrid,dv_try,ddh_try,dv,ddh
  xdv=REFORM(dv,N_ELEMENTS(dv),1)
  xddh=REFORM(ddh,N_ELEMENTS(ddh),1)
  y=Objfun(xdv,xddh,num_intf,dintf,thi,rang,bperp,dt)
  coh=MAX(y,max_subscript)
  x(1)=xdv(max_subscript)
  x(2)=xddh(max_subscript)
  ;output for deformation velocity and height error
  dv=x(1)          ;unit: mm/day, increment of deformation velocity
  PRINT,dv
  ddh=x(2)         ;unit: m, increment of height error
  PRINT,ddh
  coh=ABS(coh)
  PRINT,coh
END
PRO Meshgrid,x,y,xx,yy
  x_dim = N_ELEMENTS(x)
  xx=FLTARR(x_dim,x_dim)
  FOR i=0,x_dim-1 DO BEGIN
    FOR j=0,x_dim-1 DO BEGIN
      xx[j,i]=x[j]
    ENDFOR
  ENDFOR
  y_dim=N_ELEMENTS(y)
  y=TRANSPOSE(y)
  yy=FLTARR(y_dim,y_dim)
  FOR i=0,y_dim-1 DO BEGIN
    FOR j=0,y_dim-1 DO BEGIN
      yy[i,j]=y[j]
    ENDFOR
  ENDFOR
END
FUNCTION Objfun,x,y,num_intf,dintf,r,thi,bperp,dt
  lamda=56
  l1=4*!pi/lamda
  fun=0.0d
  dph=dintf[2,*]-dintf[1,*]
  coef_dv=l1*dt
  coef_ddh=l1*1000*bperp/(r*SIN(thi))
  FOR i=1,num_intf DO BEGIN
    fun=fun+EXP(j*(dph(i)-(coef_dv(i)*x+coef_ddh(i)*y)))
  END
  fun=ABS(fun)/num_intf
  RETURN,fun
END
PRO Dvddharcs,num_intf,num_ps,num_arcs,dv_ddh
  ;compute interferometric parameters, thi, r, bperp
  thi=DBLARR(num_ps,num_intf)
  range=DBLARR(num_ps,num_intf)
  bperp=DBLARR(num_ps,num_intf)
  ;-------------------------------
  ;first,read in PSCoor.dat
  infile=DIALOG_PICKFILE(/read,path='D:\idl\programe\idlwork\PS-InSAR',filter='*.dat',title='读取ps坐标数据文件(*.dat)')
  OPENR,lun,infile,error=err,/get_lun
  IF(err NE 0) THEN PRINTF,-2,!error_state.msg
  pscoor=ULONARR(2,num_ps)
  READU,lun,pscoor
  FREE_LUN,lun
  ;-------------------------------
  ;second, read in PSArcs.dat
  infile=DIALOG_PICKFILE(/read,path='D:\idl\programe\idlwork\PS-InSAR',filter='*.dat',title='读取ps点弧段数据文件(*.dat)')
  OPENR,lun,infile,error=err,/get_lun
  IF(err NE 0) THEN PRINTF,-2,!error_state.msg
  psno=FLTARR(2,num_arcs)
  READU,lun,psno
  FREE_LUN,lun
  ;------------------------------------
  ;finally,read time series phase data at all PS points
  infile=DIALOG_PICKFILE(/read,path='D:\idl\programe\idlwork\PS-InSAR',filter='*.dat',title='读取ps点的相位数据(*.dat)')
  OPENR,lun,infile,/get_lun
  ;  IF(err NE 0) THEN PRINTF,-2,!error_state.msg
  wphi=FLTARR(num_ps,num_intf)
  ;  help,wphi
  READU,lun,wphi
  FREE_LUN,lun
  FOR m=0,num_intf-1 DO BEGIN
    infile=DIALOG_PICKFILE(/read,path='D:\idl\programe\idlwork\default',filter='*.base',title='读取ISP基线参数文件(TCN)')     ;given the directory of baseline-parameter files
    OPENR,lun,infile,error=err,/get_lun
    IF(err NE 0) THEN PRINTF,-2,!error_state.msg
    temp=''
    line=''
    ;--------------------------------
    ;read TCN parameters from (--baseline-parameter file)
    const_tcn=DBLARR(3)
    linear_tcn=DBLARR(3)
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    const_tcn[0:2]=DOUBLE(line[1:3])        ;get constant terms of three baseline components (intial baseline from orbit data)
    READF,lun,temp
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    ;linear_tcn[0]=double(line[1])
    ;linear_tcn[1]=double(line[2])
    ;linear_tcn[2]=double(line[3])
    linear_tcn[0:2]=DOUBLE(line[1:3])        ;get linear terms of three baseline components (intial baseline rate from orbit data)
    FREE_LUN,lun
    ;---------------------------------
    ;*********************************
    ;---------------------------------
    ;open the maseter ISP-parameter file generated by Gamma
    infile=DIALOG_PICKFILE(/read,path='D:\idl\programe\idlwork\default',filter='*.slc.par',title='读取主影像ISP处理参数文件')
    OPENR,lun,infile,error=err,/get_lun
    IF(err NE 0) THEN PRINTF, -2, !error_state.msg
    FOR i=1,4 DO READF,lun,temp      ;skip the first four lines in fid2
    ;--------------------------------
    ;read the year month and date from the *.slc.par file
    year=''
    month=''
    date=''
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    year=line[1]
    month=line[2]
    date=line[3]
    IF STRLEN(month) EQ 1 THEN month='0'+month
    IF STRLEN(date) EQ 1 THEN date='0'+date
    ymd=year+month+date
    PRINT,ymd
    ;-----------------------------
    ;read the start_time
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    start_time=DOUBLE(line[1])
    PRINT,start_time
    ;-----------------------------
    ;read center_time
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    center_time=DOUBLE(line[1])
    PRINT,center_time
    ;-----------------------------
    ;read azimuth_line_time
    READF,lun,temp     ;skip one line
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    azimuth_line_time=DOUBLE(line[1])
    PRINT,azimuth_line_time
    ;-----------------------------
    ;read range_samples
    READF,lun,temp     ;skip one line
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    range_samples=FIX(line[1])
    PRINT,range_samples
    ;----------------------------
    ;read azimuth_lines
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    azimuth_lines=FIX(line[1])
    PRINT,azimuth_lines
    ;----------------------------
    FOR i=1,9 DO READF,lun,temp      ;  skip 9 lines
    ;read range_pixel_spacing
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    range_pixel_spacing=FLOAT(line[1])
    PRINT,range_pixel_spacing
    ;----------------------------
    READF,lun,temp         ;skip one line
    ;read the near_range_slc
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    near_range=DOUBLE(line[1])
    PRINT,near_range
    ;-----------------------------
    FOR i=1,18 DO READF,lun,temp      ;  skip 18 lines
    ;read the sar_to_earth_center distance h
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    h=DOUBLE(line[1])
    PRINT,h
    ;-----------------------------
    ;read earth_radius_below_sensor r
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    r=DOUBLE(line[1])
    PRINT,r
    ;------------------------------
    READF,lun,temp     ;skip one line
    READF,lun,temp     ;skip one line
    ;read number_of_state_vectors num_orbpos
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    num_orbpos=FIX(line[1])
    PRINT,num_orbpos
    ;------------------------------
    ;read time_of_first_state_vector
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    time_of_first_state_vector=DOUBLE(line[1])
    PRINT,time_of_first_state_vector
    ;------------------------------
    ;read state_vector_interval
    READF,lun,temp
    line=STRSPLIT(temp,' ',/extract)
    state_vector_interval=DOUBLE(line[1])
    PRINT,state_vector_interval
    ;-----------------------------
    x=DBLARR(num_orbpos)
    y=DBLARR(num_orbpos)
    z=DBLARR(num_orbpos)
    t=DBLARR(num_orbpos)
    vx=DBLARR(num_orbpos)
    vy=DBLARR(num_orbpos)
    vz=DBLARR(num_orbpos)
    ;read orbit positions and establish orbital models
    FOR i=0,num_orbpos-1 DO BEGIN
      t[i]=time_of_first_state_vector+i*state_vector_interval-center_time   ;get time at the the i-th orbit position
      READF,lun,temp
      line=STRSPLIT(temp,' ',/extract)
      x[i]=DOUBLE(line[1])            ;get x coordinate at the i-th orbit position
      y[i]=DOUBLE(line[2])            ;get y .....
      z[i]=DOUBLE(line[3])            ;get z .....
      READF,lun,temp        ;skip one line
      PRINT,t[i],',',x[i],'  ',y[i],'  ',z[i]
    ENDFOR
    ;--------------------------------------
    ;output model: x=coef_x(1)*t^4 +coef_x(2)*t^3 + coef_x(3)*t^2+ coef_x(4)*t + coef_x(5)
    coef_x=POLY_FIT(t, x, 4,/double)
    coef_y=POLY_FIT(t, y, 4,/double)
    coef_z=POLY_FIT(t, z, 4,/double)
    ;----------------------------------
    ;output model: x=coef_vx(1)*t^4 +coef_vx(2)*t^3 + coef_vx(3)*t^2+ coef_vx(4)*t + coef_vx(5)
    ;coef_vx=poly_fit(t, vx, 4,/double)
    ;coef_vy=poly_fit(t, vy, 4,/double)
    ;coef_vz=poly_fit(t, vz, 4,/double)
    FREE_LUN,lun
    FOR n=0,num_ps-1 DO BEGIN           ;loop on all interferograms
      ;calculate the time and range of the current pixel with coordinates of (row, col)
      current_time=start_time+(pscoor[0,n]-1)*azimuth_line_time-center_time           ;in seconds
      range[n,m]=near_range+(pscoor[1,n]-1)*range_pixel_spacing              ;get range
      ;------------------------------------
      ;calculate orbit position corresponding to the current pixel
      x_s=POLY(current_time,coef_x)
      y_s=POLY(current_time,coef_y)
      z_s=POLY(current_time,coef_z)
      real_dis=SQRT(x_s^2+y_s^2+z_s^2)             ;get real distance from sar to the earth's center
      ;-----------------------------------
      ;calculate radar look angle of the current pixell (assuming its height to be zero) using the spherical geometry
      thi[n,m]=ACOS((real_dis^2+range[n,m]^2-r^2)/(2*real_dis*range[n,m]))            ;in radians
      ;---------------------------------
      ;calculate the TCN baseline components of the current pixel
      tcn=[const_tcn[0]+linear_tcn[0]*current_time,const_tcn[1]+linear_tcn[1]*current_time, const_tcn[2]+linear_tcn[2]*current_time]
      ;----------------------------------
      ;transform TCN into out, perpendicular, and parallel baseline components
      ;tran_matrix=[1 0 0; 0 cos(-thi) sin(-thi); 0 -sin(-thi) cos(-thi)];      ;form transformation matrix
      ;Ball=tran_matrix*TCN              ;this method suggested by Douchul Yang, UT, Apr. 10, 2006
      bperp[n,m]=COS(-thi[n,m])*tcn[1,*]+SIN(-thi[n,m])*tcn[2,*]
    ENDFOR
    OPENW,lun,'e:\range.txt',/get_lun
    PRINTF,lun,range
    FREE_LUN,lun
    OPENW,lun,'e:\thi.txt',/get_lun
    PRINTF,lun,thi
    FREE_LUN,lun
    OPENW,lun,'e:\bperp.txt',/get_lun
    PRINTF,lun,bperp
    FREE_LUN,lun
  ENDFOR
  ;estimating dv and ddh along each arc (i.e., triangular side)
  ;kk=28001                ;share work with SAR server
  kk=1
  dv_ddh=DBLARR(3,num_Arcs-kk+1)
  FOR i=kk,num_arcs DO BEGIN
    ii=psno[1,i]     ;get the number of the 1st ps point of the current arc
    jj=psno[2,i]     ;get the number of the 2st ps point of the current arc
    thita=(TRANSPOSE(thi[*,ii])+TRANSPOSE(thi[*,jj]))/2   ; averaging on thi
    rg=(TRANSPOSE(range[*,ii])+TRANSPOSE(range[*,jj]))/2       ;averaging on r
    bp=(TRANSPOSE(bperp[*,ii])+TRANSPOSE(bperp[*,jj]))/2     ;averaging on bperp
    ;estimating increment of deformation rate and dem error between
    ;two neighbouring permanent scatterers (ps) by means of maximizing
    ;model coherence value
    Incsolut,num_intf,[wphi[jj,*],wphi[jj,*]],rg,thita,bp,dt,dv_ddh[1,i-kk+1],dv_ddh[2,i-kk+1],dv_ddh[3,i-kk+1]
    PRINT,dv_ddh[1,i-kk+1],'  ',dv_ddh[2,i-kk+1],'  ',dv_ddh[3,i-kk+1]
  ENDFOR
END
PRO Comp_dv_ddh_event,event
  WIDGET_CONTROL,event.top,get_uvalue=pstate
  uname = WIDGET_INFO(event.id,/uname)
  CASE uname OF
    'cancel':BEGIN
    tmp = DIALOG_MESSAGE('确实放弃dv_ddh的计算？', $
      title='关闭计算窗口',/question)
    IF tmp EQ 'yes' THEN BEGIN
      WIDGET_CONTROL,event.top,/destroy
    ENDIF
    WIDGET_CONTROL,event.top,get_uvalue = pstate
    PTR_FREE, pstate
    WIDGET_CONTROL,event.top,/destroy
    RETURN
  END
  'num_intf':BEGIN
  WIDGET_CONTROL,(*pstate).txt_num_intf,get_value=num_intf
  WIDGET_CONTROL,(*pstate).txt_num_intf,set_uvalue=num_intf
  PRINT,num_intf
END
'num_ps':BEGIN
WIDGET_CONTROL,(*pstate).txt_num_ps,get_value=num_ps
WIDGET_CONTROL,(*pstate).txt_num_ps,set_uvalue=num_ps
PRINT,num_ps
END
'num_arcs':BEGIN
WIDGET_CONTROL,(*pstate).txt_num_arcs,get_value=num_arcs
WIDGET_CONTROL,(*pstate).txt_num_arcs,set_uvalue=num_arcs
PRINT,num_arcs
END
'comp':BEGIN
WIDGET_CONTROL,(*pstate).txt_num_intf,get_uvalue=num_intf
WIDGET_CONTROL,(*pstate).txt_num_ps,get_uvalue=num_ps
WIDGET_CONTROL,(*pstate).txt_num_arcs,get_uvalue=num_arcs
IF num_intf EQ '' THEN BEGIN
  tmp = DIALOG_MESSAGE('请输入干涉图数量参数！', $
    title='提示',/information)
  IF tmp EQ 'yes' THEN WIDGET_CONTROL,event.top,/destroy
  RETURN
ENDIF ELSE BEGIN
  IF num_ps EQ '' THEN BEGIN
    tmp = DIALOG_MESSAGE('请输入ps点数量参数！', $
      title='提示',/information)
    IF tmp EQ 'yes' THEN WIDGET_CONTROL,event.top,/destroy
    RETURN
  ENDIF ELSE BEGIN
    IF num_arcs EQ '' THEN BEGIN
      tmp = DIALOG_MESSAGE('请输入弧段数量参数！', $
        title='提示',/information)
      IF tmp EQ 'yes' THEN WIDGET_CONTROL,event.top,/destroy
      RETURN
    ENDIF
  ENDELSE
ENDELSE
num_intf=UINT(num_intf)
num_ps=ULONG(num_ps)
num_arcs=ULONG(num_arcs)
;PRINT,num_intf+num_ps+num_arcs
Dvddharcs,num_intf,num_ps,num_arcs,dv_ddh
END
ENDCASE
END

PRO SARGUI_TIMESERIES,event
  mybase=WIDGET_BASE(xsize=500,ysize=250,title='线性形变速率及高程误差增量估计',uname='mybase')
  ;paratextbase
  paratextbase=WIDGET_BASE(mybase,frame=1,xoffset=25,yoffset=50,xsize=450,ysize=60,column=3,/grid_layout)
  lbl_title_para=WIDGET_LABEL(mybase,value='计算所需参数输入',xoffset=200,yoffset=20)
  lbl_num_intf= WIDGET_LABEL(paratextbase,value='干涉图数量:')
  txt_num_intf= WIDGET_TEXT(paratextbase,/editable,uname='num_intf',value='',uvalue='',/kbrd_focus_events)
  lbl_num_ps= WIDGET_LABEL(paratextbase,value='PS点数量:',yoffset=75)
  txt_num_ps=WIDGET_TEXT(paratextbase,/editable,uname='num_ps',value='',uvalue='',/kbrd_focus_events)
  lbl_num_arcs= WIDGET_LABEL(paratextbase,value='弧段数量:',yoffset=115)
  txt_num_arcs=WIDGET_TEXT(paratextbase,/editable,uname='num_arcs',uvalue='',value='',/kbrd_focus_events)
  lbl_tiltle_info=WIDGET_LABEL(mybase,value='计算过程信息显示',xoffset=200,yoffset=120)
  compinfobase=WIDGET_BASE(mybase,frame=1,xoffset=25,yoffset=140,xsize=450,ysize=50)
  btn_comp=WIDGET_BUTTON(mybase,value='计算',xoffset=50,xsize=100,ysize=30,yoffset=200,uname='comp')
  btn_save=WIDGET_BUTTON(mybase,value='保存',xoffset=200,xsize=100,ysize=30,yoffset=200,uvalue='save')
  btn_cancel=WIDGET_BUTTON(mybase,value='取消',xoffset=350,xsize=100,ysize=30,yoffset=200,uname='cancel')
  ;create structure
  state={txt_num_intf:txt_num_intf,txt_num_ps:txt_num_ps,txt_num_arcs:txt_num_arcs,btn_comp:btn_comp,$
    btn_save:btn_save,btn_cancel:btn_cancel}
  ;create pointer
  pstate=PTR_NEW(state,/no_copy)
  ;to save pstate in mybase uvalue
  WIDGET_CONTROL,mybase,set_uvalue=pstate
  ;realize and manage comp_dv_ddh's mybase
  WIDGET_CONTROL,mybase,/realize
  XMANAGER,'comp_dv_ddh',mybase,/no_block
END